<%= javascript_pack_tag 'files/clipboard' %>
<%= javascript_pack_tag 'files/datatable' %>
<%= javascript_pack_tag 'files/common' %>
<%= javascript_pack_tag 'files/fileops' %>

<script>
const csrf_token = document.querySelector('meta[name="csrf-token"]').content;

// this uses event delegation so it captures events even if dom element is recreated
var clipboardjs = new ClipboardJS('#copy-path');

history.replaceState({
  currentDirectory: '<%= @path %>',
  currentDirectoryUrl: '<%= files_path(@path) %>',
  currentDirectoryUpdatedAt: '<%= Time.now.to_i %>'
}, null);


<% unless alert %>
// initial data load
reloadTable();
<% end %>

$('#path-breadcrumbs').on('click', '#goto-btn', function(){
  Swal.fire({
    title: 'Change Directory',
    input: 'text',
    inputLabel: 'Path',
    inputValue: history.state.currentDirectory,
    inputAttributes: {
      spellcheck: 'false',
    },
    showCancelButton: true,
    inputValidator: (value) => {
      if (! value || ! value.startsWith('/')) {
        // TODO: validate filenames against listing
        return 'Provide an absolute pathname'
      }
    }
  })
  .then((result) => result.isConfirmed ? Promise.resolve(result.value) : Promise.reject('cancelled'))
  .then((pathname) => goto('<%= files_path('/') %>' + pathname))
});


// https://github.com/transloadit/uppy/blob/7ce58beeb620df3df0640cb369f5d71e3d3f751f/packages/%40uppy/utils/src/getDroppedFiles/utils/webkitGetAsEntryApi/getFilesAndDirectoriesFromDirectory.js
/**
 * Recursive function, calls the original callback() when the directory is entirely parsed.
 *
 * @param {FileSystemDirectoryReader} directoryReader
 * @param {Array} oldEntries
 * @param {Function} logDropError
 * @param {Function} callback - called with ([ all files and directories in that directoryReader ])
 */
function getFilesAndDirectoriesFromDirectory (directoryReader, oldEntries, logDropError, { onSuccess }) {
  directoryReader.readEntries(
    (entries) => {
      const newEntries = [...oldEntries, ...entries]
      // According to the FileSystem API spec, getFilesAndDirectoriesFromDirectory() must be called until it calls the onSuccess with an empty array.
      if (entries.length) {
        setTimeout(() => {
          getFilesAndDirectoriesFromDirectory(directoryReader, newEntries, logDropError, { onSuccess })
        }, 0)
      // Done iterating this particular directory
      } else {
        onSuccess(newEntries)
      }
    },
    // Make sure we resolve on error anyway, it's fine if only one directory couldn't be parsed!
    (error) => {
      logDropError(error)
      onSuccess(oldEntries)
    }
  )
}

(function(){
  class EmptyDirCreator extends BasePlugin {
    constructor (uppy, opts){
      super(uppy, opts)
      this.id = this.opts.id || 'EmptyDirUploaderCatcher';
      this.type = 'acquirer';

      this.empty_dirs = [];
      this.last_entries = [];

      this.handleRootDrop = this.handleRootDrop.bind(this);
      this.createEmptyDirs = this.createEmptyDirs.bind(this);

      this.uppy = uppy;
    }

    handleRootDrop (e) {
      // from https://github.com/transloadit/uppy/blob/7ce58beeb620df3df0640cb369f5d71e3d3f751f/packages/%40uppy/utils/src/getDroppedFiles/index.js
      if (e.dataTransfer.items && e.dataTransfer.items[0] && 'webkitGetAsEntry' in e.dataTransfer.items[0]) {
        // toArray https://github.com/transloadit/uppy/blob/7ce58beeb620df3df0640cb369f5d71e3d3f751f/packages/%40uppy/utils/src/toArray.js#L4
        let items = Array.prototype.slice.call(e.dataTransfer.items || [], 0);
        let entries = items.map(i => i.webkitGetAsEntry()).filter(i => i);

        return Promise.all(entries.map(i => getEmptyDirs(i))).then((dirs) => {
          this.empty_dirs = this.empty_dirs.concat(_.flattenDeep(dirs));

          console.log(this.empty_dirs);
        });
      }
      //else we don't have access to directory information
    }

    createEmptyDirs (ids) {
      if(! this.uppy.getState().error){ // avoid creating empty dirs if error occurred during upload

        //TODO: error checking and reporting
        return Promise.all(this.empty_dirs.map((d) => {
          // "fullPath" should actually be the path relative to the current directory
          let filename = _.trimStart(d.fullPath, '/');

          return fetch(`${history.state.currentDirectoryUrl}/${encodeURI(filename)}?dir=true`, {method: 'put', headers: { 'X-CSRF-Token': csrf_token }})
          //TODO: parse json response verify if there was an error creating directory and handle error

        })).then(() => this.empty_dirs = []);
      }
    }

    install () {
      this.uppy.addPostProcessor(this.createEmptyDirs);
    }

    uninstall () {
      this.uppy.removePostProcessor(this.createEmptyDirs);
    }
  }

  function closeAndResetUppyModal(uppy){
    uppy.getPlugin('Dashboard').closeModal();
    uppy.reset();
  }


  window.uppy = new Uppy({
    restrictions: {
      maxFileSize: <%= Configuration.file_upload_max %>,
    }
  });
  uppy.use(EmptyDirCreator);
  uppy.use(Dashboard, {
    trigger: '#upload-btn',
    fileManagerSelectionType: 'both',
    disableThumbnailGenerator: true,
    showLinkToFileUploadResult: false,
    closeModalOnClickOutside: true,
    closeAfterFinish: true,
    allowMultipleUploads: false,
    onRequestCloseModal: () => closeAndResetUppyModal(uppy),
    note: 'Empty directories will be included in the upload only when a directory upload is initiated via drag and drop. This is because the File and Directory Entries API is available only on a drop event, not during an input change event.'
  });
  uppy.use(XHRUpload, {
    endpoint: '<%= files_upload_path %>',
    withCredentials: true,
    fieldName: 'file',
    limit: 1,
    headers: { 'X-CSRF-Token': csrf_token },
    timeout: 128 * 1000,
  });

  uppy.on('file-added', (file) => {
    uppy.setFileMeta(file.id, { parent: history.state.currentDirectory });
    if(file.meta.relativePath == null && file.data.webkitRelativePath){
      uppy.setFileMeta(file.id, { relativePath: file.data.webkitRelativePath });
    }
  });

  uppy.on('complete', (result) => {
    if(result.successful.length > 0){
      reloadTable();
    }
  });

  // https://stackoverflow.com/questions/6756583/prevent-browser-from-loading-a-drag-and-dropped-file
  window.addEventListener("dragover",function(e){
    e = e || event;
    e.preventDefault();
  },false);
  window.addEventListener("drop",function(e){
    e = e || event;
    e.preventDefault();
  },false);

  $('#directory-contents').on('drop', function(e){
    this.classList.remove('dragover');
    console.log('File(s) dropped');
    // Prevent default behavior (Prevent file from being opened)

    // pass drop event to uppy dashboard
    uppy.getPlugin('Dashboard').openModal().then(() => uppy.getPlugin('Dashboard').handleDrop(e.originalEvent))
  });

  $('#directory-contents').on('dragover', function(e){
    this.classList.add('dragover');

    // Prevent default behavior (Prevent file from being opened)
    e.preventDefault();

    // specifies what feedback will be shown to the user by setting the dropEffect attribute of the DataTransfer associated with the event
    // too bad we can't show an indicator (no dragstart/end when dragging from OS to browser)
    e.originalEvent.dataTransfer.dropEffect = 'copy';
  });

  $('#directory-contents').on('dragleave', function(e){
    this.classList.remove('dragover');
  });

})();

window.onpopstate = function(event){
  // FIXME: handle edge case if state ! exist
  setTimeout(() => {
    goto(event.state.currentDirectoryUrl, false);
  }, 0);
};

// borrowed from Turbolinks
// event: MouseEvent
function clickEventIsSignificant(event) {
  return !(
    // (event.target && (event.target as any).isContentEditable)
       event.defaultPrevented
    || event.which > 1
    || event.altKey
    || event.ctrlKey
    || event.metaKey
    || event.shiftKey
  )
}

// this would be perfect for stimulus FYI
$('#directory-contents tbody').on('click', '.view-file', function(e){
  e.preventDefault();

  window.open(this.href, 'ViewFile', "location=yes,resizable=yes,scrollbars=yes,status=yes");
});

$('#directory-contents tbody').on('click', '.delete-file', function(e){
  e.preventDefault();

  let row = table.row(this.dataset.rowIndex).data();
  deleteFiles([row.name]);
});

$('#directory-contents tbody').on('click', '.download-file', function(e){
  e.preventDefault();

  let file = table.row(this.dataset.rowIndex).data();

  if(file.type == 'd') {
    downloadDirectory(file)
  }
  else {
    downloadFile(file)
  }
});

$('#directory-contents tbody').on('click', '.rename-file', function(e){
  e.preventDefault();

  let row = table.row(this.dataset.rowIndex).data();

  // if there was some other attribute that just had the name...
  let filename = $($.parseHTML(row.name)).text();

  Swal.fire({
    title: 'Rename',
    input: 'text',
    inputLabel: 'Filename',
    inputValue: filename,
    inputAttributes: {
      spellcheck: 'false',
    },
    showCancelButton: true,
    inputValidator: (value) => {
      if (! value) {
        // TODO: validate filenames against listing
        return 'Provide a filename to rename this to';
      }
      else if (value.includes('/') || value.includes('..')){
       return 'Filename cannot include / or ..';
      }
    }
  })
  .then((result) => result.isConfirmed ? Promise.resolve(result.value) : Promise.reject('cancelled'))
  .then((new_filename) => renameFile(filename, new_filename))
});

$('#directory-contents tbody, #path-breadcrumbs, #favorites').on('click', 'a.d', function(){
  if(clickEventIsSignificant(event)){
    event.preventDefault();
    event.cancelBubble = true;
    if(event.stopPropagation) event.stopPropagation();

    goto(this.getAttribute("href"));
  }
});

$('#directory-contents tbody').on('dblclick', 'tr td:not(:first-child)', function(){
    // handle doubleclick
    let a = this.parentElement.querySelector('a');
    if(a.classList.contains('d')) goto(a.getAttribute("href"));
});

function clearClipboard(){
   localStorage.removeItem('filesClipboard');
}

function updateClipboardFromSelection(){
  let selection = table.rows({selected: true}).data();
  if(selection.length == 0){
    clearClipboard();
  }
  else {
    let clipboardData = {
      from: history.state.currentDirectory,
      files: selection.toArray().map((f) => {
          return { directory: f.type == 'd', name: f.name };
      })
    };

    localStorage.setItem('filesClipboard', JSON.stringify(clipboardData));
  }
}

function transferFiles(files, action, summary){
  loading(_.startCase(summary));

  return fetch('<%= transfers_path(format: "json") %>', {
    method: 'post',
    body: JSON.stringify({
      command: action,
      files: files
    }),
    headers: { 'X-CSRF-Token': csrf_token }
  })
  .then(response => dataFromJsonResponse(response))
  .then((data) => {

    if(! data.completed){
      // was async, gotta report on progress and start polling
      reportTransfer(data);
    }
    else {
      if(data.target_dir == history.state.currentDirectory){
        reloadTable();
      }
    }

    if(action == 'mv' || action == 'cp'){
      clearClipboard();
      updateViewForClipboard();
    }
  })
  .then(() => doneLoading())
  .catch(e => alertError('Error occurred when attempting to ' + summary, e.message))
}

const reportTransferTemplate = (function(){
  let template_str  = $('#transfer-template').html();
  return Handlebars.compile(template_str);
})();

function findAndUpdateTransferStatus(data){
  let id = `#${data.id}`;

  if($(id).length){
    $(id).replaceWith(reportTransferTemplate(data));
  }
  else{
    $('.transfers-status').append(reportTransferTemplate(data));
  }
}

function fadeOutTransferStatus(data){
  let id = `#${data.id}`;
  $(id).fadeOut(4000);
}


function reportTransfer(data){
  // 1. add the transfer label
  findAndUpdateTransferStatus(data);

  let attempts = 0

  // 2. poll for the updates
  var poll = function() {
    $.getJSON(data.show_json_url, function (newdata) {
      findAndUpdateTransferStatus(newdata);

      if(newdata.completed) {
        if(! newdata.error_message) {
          if(newdata.target_dir == history.state.currentDirectory) {
            reloadTable();
          }

          // 3. fade out after 5 seconds
          fadeOutTransferStatus(newdata)
        }
      }
      else {
        // not completed yet, so poll again
        setTimeout(poll, 1000);
      }
    }).fail(function() {
      if (attempts >= 3) {
        Swal.fire('Operation may not have happened', 'Failed to retrieve file operation status.', 'error');
      } else {
        setTimeout(poll, 1000);
        attempts++;
      }
    });
  }

  poll();
}

function renameFile(filename, new_filename){
  let files = {};
  files[`${history.state.currentDirectory}/${filename}`] = `${history.state.currentDirectory}/${new_filename}`;
  transferFiles(files, "mv", "rename file")
}

function moveFiles(files, summary = "move files"){
  transferFiles(files, "mv", "move files")
}

function copyFiles(files){
  transferFiles(files, "cp", "copy files")
}

function removeFiles(files){
  transferFiles(files, "rm", "remove files")
}


$('#copy-move-btn').on("click", () => {
    updateClipboardFromSelection();
    updateViewForClipboard();
});

function deleteFiles(files){
  if(! files.length > 0){
    return;
  }

  Swal.fire({
    title: files.length == 1 ? `Delete ${files[0]}?` : `Delete ${files.length} selected files?`,
    text: 'Are you sure you want to delete the files: ' + files.join(', '),
    showCancelButton: true,
  })
  .then((result) => {
    if(result.isConfirmed){
      loading('Deleting files...');
      removeFiles(files.map(f => [history.state.currentDirectory, f].join('/')), csrf_token);
    }
  })
}


// TODO: move all functionality out of click handlers to functions
// TODO: disable copy/move buttons if no local storage


</script>
