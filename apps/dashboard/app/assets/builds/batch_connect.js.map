{
  "version": 3,
  "sources": ["../../javascript/packs/batch_connect.js"],
  "sourcesContent": ["'use strict';\n\nconst bcPrefix = 'batch_connect_session_context';\nconst shortNameRex = new RegExp(`${bcPrefix}_([\\\\w\\\\-]+)`);\nconst tokenRex = /([A-Z][a-z]+){1}([\\w\\-]+)/;\n\n// @example ['NodeType', 'Cluster']\nconst formTokens = [];\n\n// simple lookup table to indicate that the change handler is setup between two\n// elements. I.e., {'cluster': [ 'node_type' ] } means that changes to cluster\n// trigger changes to node_type\nconst optionForHandlerCache = {};\n\n\n// simples array of string ids for elements that have a handler\nconst minMaxHandlerCache = [];\nconst setHandlerCache = [];\n// hide handler cache is a map in the form '{ from: [hideThing1, hideThing2] }'\nconst hideHandlerCache = {};\n\n// Lookup tables for setting min & max values\n// for different directives.\nconst minMaxLookup = {};\nconst setValueLookup = {};\nconst hideLookup = {};\n\n// the regular expression for mountain casing\nconst mcRex = /[-_]([a-z])|([_-][0-9])/g;\n\nfunction bcElement(name) {\n  return `${bcPrefix}_${name.toLowerCase()}`;\n};\n\n// here the simple name for 'batch_connect_session_context_cluster'\n// is just 'cluster'.\nfunction shortId(elementId) {\n  const match = elementId.match(shortNameRex);\n\n  if (match.length >= 1) {\n    return match[1];\n  } else {\n    return '';\n  };\n};\n\n/**\n * Mountain case the words from a string, by tokenizing on [-_].  In the\n * simplest case it just capitalizes.\n *\n * There is a special case where seperators are followed numbers. In this case\n * The seperator is kept as a hyphen because that's how jQuery expects it.\n *\n * @param      {string}  str     The word string to mountain case\n *\n * @example  given 'foo' this returns 'Foo'\n * @example  given 'foo-bar' this returns 'FooBar'\n * @example  given 'physics_1234' this returns 'Physics-1234'\n */\n// Convert dashed to camelCase\nfunction mountainCaseWords(str) {\n  const lower = str.toLowerCase();\n  const first = lower.charAt(0).toUpperCase();\n  const rest = lower.slice(1).replace(mcRex, function(_all, letter, prefixedNumber) {\n    return letter ? letter.toUpperCase() : prefixedNumber.replace('_','-');\n  });\n\n  return  `${first}${rest}`;\n}\n\nfunction snakeCaseWords(str) {\n  if(str === undefined) return undefined;\n\n  let snakeCase = \"\";\n  let first = true;\n\n  str.split('').forEach((c) => {\n    if (first) {\n      first = false;\n      snakeCase += c.toLowerCase();\n    } else if(c === '-' || c === '_') {\n      snakeCase += '_';\n    } else if(c == c.toUpperCase() && !(c >= '0' && c <= '9')) {\n      snakeCase += `_${c.toLowerCase()}`;\n    } else {\n      snakeCase += c;\n    }\n  });\n\n  return snakeCase;\n}\n\n/**\n *\n * @param {Array} elements\n */\nfunction memorizeElements(elements) {\n  elements.each((_i, ele) => {\n    formTokens.push(mountainCaseWords(shortId(ele['id'])));\n    optionForHandlerCache[ele['id']] = [];\n  });\n};\n\nfunction makeChangeHandlers(){\n  const allElements = $(`[id^=${bcPrefix}]`);\n  memorizeElements(allElements);\n\n  allElements.each((_i, element) => {\n    if (element['type'] == \"select-one\"){\n      let optionSearch = `#${element['id']} option`;\n      let options = $(optionSearch);\n      options.each((_i, opt) => {\n          // the variable 'opt' is just a data structure, not a jQuery result. \n          // it has no attr, data, show or hide methods so we have to query\n          // for it again\n          let data = $(`${optionSearch}[value='${opt.value}']`).data();\n          let keys = Object.keys(data);\n          if(keys.length !== 0) {\n            keys.forEach((key) => {\n              if(key.startsWith('optionFor')) {\n                let token = key.replace(/^optionFor/,'');\n                addOptionForHandler(idFromToken(token), element['id']);\n              } else if(key.startsWith('max') || key.startsWith('min')) {\n                addMinMaxForHandler(element['id'], opt.value, key, data[key]);\n              } else if(key.startsWith('set')) {\n                addSetHandler(element['id'], opt.value, key, data[key]);\n              } else if(key.startsWith('hide')) {\n                addHideHandler(element['id'], opt.value, key, data[key]);\n              }\n            });\n          }\n      });\n    }\n  });\n};\n\nfunction addHideHandler(optionId, option, key,  configValue) {\n  const changeId = idFromToken(key.replace(/^hide/,''));\n\n  if(hideLookup[optionId] === undefined) hideLookup[optionId] = new Table(changeId, 'option_value');\n  const table = hideLookup[optionId];\n  table.put(changeId, option, configValue);\n\n  if(hideHandlerCache[optionId] === undefined) hideHandlerCache[optionId] = [];\n\n  if(!hideHandlerCache[optionId].includes(changeId)) {\n    const changeElement = $(`#${optionId}`);\n\n    changeElement.on('change', (event) => {\n      updateVisibility(event, changeId);\n    });\n\n    hideHandlerCache[optionId].push(changeId);\n  }\n\n  updateVisibility({ target: document.querySelector(`#${optionId}`) }, changeId);\n}\n\n/**\n *\n * @param {*} optionId batch_connect_session_context_node_type\n * @param {*} option gpu\n * @param {*} key maxNumCoresForClusterAnnieOakley\n * @param {*} configValue 42\n *\n * node_type:\n *   widget: select\n *   options:\n *    - [\n *        'gpu',\n *        data-max-num-cores-for-cluster-annie-oakley: 42\n *      ]\n */\nfunction addMinMaxForHandler(optionId, option, key,  configValue) {\n  optionId = String(optionId || '');\n\n  const configObj = parseMinMaxFor(key);\n  const id = configObj['subjectId'];\n  // this is the id of the target object we're setting the min/max for.\n  // if it's undefined - there's nothing to do, it was likely configured wrong.\n  if(id === undefined) return;\n\n  const secondDimId = configObj['predicateId'];\n  const secondDimValue = configObj['predicateValue'];\n\n  if(minMaxLookup[id] === undefined) minMaxLookup[id] = new Table(optionId, secondDimId);\n  const table = minMaxLookup[id];\n  table.put(option, secondDimValue, {[minOrMax(key)] : configValue });\n\n  let cacheKey = `${optionId}_${secondDimId}`;\n  if(!minMaxHandlerCache.includes(cacheKey)) {\n    const changeElement = $(`#${optionId}`);\n\n    changeElement.on('change', (event) => {\n      toggleMinMax(event, id, secondDimId);\n    });\n\n    minMaxHandlerCache.push(cacheKey);\n  }\n\n  cacheKey = `${secondDimId}_${optionId}`;\n  if(secondDimId !== undefined && !minMaxHandlerCache.includes(cacheKey)){\n    const secondEle = $(`#${secondDimId}`);\n\n    secondEle.on('change', (event) => {\n      toggleMinMax(event, id, optionId);\n    });\n\n    minMaxHandlerCache.push(cacheKey);\n  }\n}\n\n/**\n *\n * @param {*} optionId batch_connect_session_context_classroom\n * @param {*} option 'PHY_9000'\n * @param {*} key setAccount\n * @param {*} configValue 'phy3005'\n *\n * classroom:\n *   widget: select\n *   options:\n *    - [\n *        'Physics Maximum', 'PHY_9000',\n *        data-set-account: 'phy3005'\n *      ]\n */\nfunction addSetHandler(optionId, option, key,  configValue) {\n  const k = key.replace(/^set/,'');\n  const id = String(idFromToken(k));\n  if(id === 'undefined') return;\n\n  // id is account. optionId is classroom\n  let cacheKey = `${id}_${optionId}`\n  if(setValueLookup[cacheKey] === undefined) setValueLookup[cacheKey] = new Table(optionId, undefined);\n  const table = setValueLookup[cacheKey];\n  table.put(option, undefined, configValue);\n\n  if(!setHandlerCache.includes(cacheKey)) {\n    const changeElement = $(`#${optionId}`);\n\n    changeElement.on('change', (event) => {\n      setValue(event, id);\n    });\n\n    setHandlerCache.push(cacheKey);\n  }\n\n  setValue({ target: document.querySelector(`#${optionId}`) }, id);\n}\n\nfunction setValue(event, changeId) {\n  const chosenVal = event.target.value;\n  const cacheKey = `${changeId}_${event.target['id']}`\n  const table = setValueLookup[cacheKey];\n  if (table === undefined) return;\n\n  const changeVal = table.get(chosenVal, undefined);\n\n  if(changeVal !== undefined) {\n    const innerElement = $(`#${changeId}`);\n    innerElement.attr('value', changeVal);\n    innerElement.val(changeVal);\n  }\n}\n\n/**\n *\n *  This is a simple table class to describe the relationship between\n *  two different element types as a table with named columns.\n *\n *  table.get('gpu','owens') would return the value shown.\n *\n *      'oakley'   |                    |                |\n *      'owens'    | { min: 3, max: 42} |                |\n *                 |  'gpu'             |   'hugemem'    |\n *\n * In the simple case, it's a 1d vector instead of a 2d matrix. This\n * allows for, say, gpu to have the same min & max across clusters.\n */\nclass Table {\n  constructor(x, y) {\n    // FIXME: probably need to make Vector class? Wouldn't want to add a flag to the constructor.\n    // we don't use x or y internally, though x is used externally.\n    this.x = x;\n    this.xIdxLookup = {};\n\n    this.y = y;\n    this.yIdxLookup = {};\n    this.table = y === undefined ? [] : [[]];\n  }\n\n  put(x, y, value) {\n    if(!x) return;\n    x = snakeCaseWords(x);\n    y = snakeCaseWords(y);\n\n    if(this.xIdxLookup[x] === undefined) this.xIdxLookup[x] = Object.keys(this.xIdxLookup).length;\n    if(y && this.yIdxLookup[y] === undefined) this.yIdxLookup[y] = Object.keys(this.yIdxLookup).length;\n\n    const xIdx = this.xIdxLookup[x];\n    const yIdx = this.yIdxLookup[y];\n\n    if(this.table[xIdx] === undefined ){\n      this.table[xIdx] = y === undefined ? undefined : [];\n    }\n\n    // if y's index is defined, then it's a 2d matrix. Otherwise a 1d vector.\n    if(yIdx === undefined) {\n      if(this.table[xIdx] === undefined){\n        this.table[xIdx] = value;\n      } else {\n        const prev = this.table[xIdx];\n        const newer = value;\n        this.table[xIdx] = Object.assign(prev, newer);\n      }\n    } else {\n      if(this.table[xIdx][yIdx] === undefined){\n        this.table[xIdx][yIdx] = value;\n      } else {\n        const prev = this.table[xIdx][yIdx];\n        const newer = value;\n        this.table[xIdx][yIdx] = Object.assign(prev, newer);\n      }\n    }\n  }\n\n  get(x, y) {\n    const xIdx = this.xIdxLookup[snakeCaseWords(x)];\n    const yIdx = this.yIdxLookup[snakeCaseWords(y)];\n\n    if(this.table[xIdx] === undefined){\n      return undefined;\n    }else if(y === undefined){\n      return this.table[xIdx];\n    }else {\n      return this.table[xIdx][yIdx];\n    }\n  }\n}\n\n/**\n * Update the visibility of `changeId` based on the\n * event and what's in the hideLookup table.\n */\nfunction updateVisibility(event, changeId) {\n  const val = event.target.value;\n  const id = event.target['id'];\n  const changeElement = $(`#${changeId}`).parent();\n\n  if (changeElement.length <= 0) return;\n\n  // safe to access directly?\n  const hide = hideLookup[id].get(changeId, val);\n  if(hide === undefined) {\n    changeElement.show();\n  }else if(hide === true) {\n    changeElement.hide();\n  }\n}\n\nfunction toggleMinMax(event, changeId, otherId) {\n  let x = undefined, y = undefined;\n\n  // in the example of cluster & node_type, either element can trigger a change\n  // so let's figure out the axis' based on the change element's id.\n  if(event.target['id'] == minMaxLookup[changeId].x) {\n    x = snakeCaseWords(event.target.value);\n    y = snakeCaseWords($(`#${otherId}`).val());\n  } else {\n    y = snakeCaseWords(event.target.value);\n    x = snakeCaseWords($(`#${otherId}`).val());\n  }\n\n  const changeElement = $(`#${changeId}`);\n  const mm = minMaxLookup[changeId].get(x, y);\n  const prev = {\n    min: changeElement.attr('min'),\n    max: changeElement.attr('max'),\n  };\n\n  [ 'max', 'min' ].forEach((dim) => {\n    if(mm && mm[dim] !== undefined) {\n      changeElement.attr(dim, mm[dim]);\n    }\n  });\n\n  const val = clamp(changeElement.val(), prev, mm)\n  if (val !== undefined) {\n    changeElement.attr('value', val);\n    changeElement.val(val);\n  }\n}\n\nfunction clamp(currentValue, previous, next) {\n  if(next === undefined){\n    return undefined;\n\n  // you've set the boundary, so when you go to the next value - keep it at the next's boundary\n  } else if(previous && previous['max'] && currentValue == previous['max']) {\n    return next['max'];\n  } else if(previous && previous['min'] && currentValue == previous['min']) {\n    return next['min'];\n\n  // otherwise you could be up or down shifting to fit within the next's boundaries\n  } else if(next['max'] && currentValue >= next['max']) {\n    return next['max'];\n  } else if(next['min'] && currentValue <= next['min']) {\n    return next['min'];\n  } else {\n    return undefined;\n  }\n}\n\nfunction addOptionForHandler(causeId, targetId) {\n  const changeId = String(causeId || '');\n\n  if(changeId.length == 0 || optionForHandlerCache[causeId].includes(targetId)) {\n    // nothing to do. invalid causeId or we already have a handler between the 2\n    return;\n  }\n\n  let causeElement = $(`#${causeId}`);\n\n  if(targetId && causeElement) {\n    // cache the fact that there's a new handler here\n    optionForHandlerCache[causeId].push(targetId);\n\n    causeElement.on('change', (event) => {\n      toggleOptionsFor(event, targetId);\n    });\n\n    // fake an event to initialize\n    toggleOptionsFor({ target: document.querySelector(`#${causeId}`) }, targetId);\n  }\n};\n\n/**\n *\n * @param {*} key minNumCoresForClusterAnnieOakley\n * @returns\n *\n *  {\n *    'subjectId': 'batch_connect_session_context_num_cores',\n *    'predicateId': 'batch_connect_session_context_cluster',\n *    'predicateValue': 'annie_oakley'\n *  }\n */\nfunction parseMinMaxFor(key) {\n  let k = undefined;\n  let predicateId = undefined;\n  let predicateValue = undefined;\n  let subjectId = undefined;\n\n  if(key.startsWith('min')) {\n    k = key.replace(/^min/,'');\n  } else if(key.startsWith('max')) {\n    k = key.replace(/^max/, '')\n  }\n\n  //trying to parse maxNumCoresForClusterOwens\n  const tokens = k.match(/^(\\w+)For(\\w+)$/);\n\n  if(tokens == null) {\n    // the key is likely just maxNumCores with no For clause\n    subjectId = idFromToken(k);\n\n  } else if(tokens.length == 3) {\n    const subject = tokens[1];\n    const predicateFull = tokens[2];\n    subjectId = idFromToken(subject);\n\n    const predicateTokens = predicateFull.split(/(?=[A-Z])/);\n    if(predicateTokens && predicateTokens.length >= 2) {\n\n      // if there are only 2 tokens then it's like 'ClusterOwens' which is easy\n      if(predicateTokens.length == 2) {\n        predicateId = idFromToken(predicateTokens[0]);\n        predicateValue = predicateTokens[1];\n\n      // else it's like NodeTypeFooBar, so it's a little more difficult\n      } else {\n        let tokenString = '';\n        let done = false;\n        predicateTokens.forEach((pt, idx) => {\n          if(done) { return; }\n\n          tokenString = `${tokenString}${pt}`\n          let tokenId = idFromToken(tokenString);\n          if(tokenId !== undefined) {\n            done = true;\n            predicateId = tokenId;\n            predicateValue = predicateTokens.slice(idx+1).join('');\n          }\n        })\n      }\n    }\n  }\n\n  return {\n    'subjectId': subjectId,\n    'predicateId': predicateId,\n    'predicateValue': snakeCaseWords(predicateValue),\n  }\n}\n\nfunction minOrMax(key) {\n  if(key.startsWith('min')){\n    return 'min';\n  } else if(key.startsWith('max')){\n    return 'max';\n  } else {\n    return null;\n  }\n}\n\n/**\n * Turn a MountainCase token into a form element id\n *\n * @example\n *  NodeType -> batch_connect_session_context_node_type\n *\n * @param {*} str\n * @returns\n */\n\nfunction idFromToken(str) {\n  return formTokens.map((token) => {\n    let match = str.match(`^${token}{1}`);\n\n    if (match && match.length >= 1) {\n      let ele = snakeCaseWords(match[0]);\n      return bcElement(ele);\n    }\n  }).filter((id) => {\n    return id !== undefined;\n  })[0];\n}\n\n/**\n * Hide or show options of an element based on which cluster is\n * currently selected and the data-option-for-CLUSTER attributes\n * for each option\n *\n * @param      {string}  element_name  The name of the element with options to toggle\n */\n function toggleOptionsFor(event, elementId) {\n  const options = $(`#${elementId} option`);\n\n  // If I'm changing cluster to 'oakely', optionFor is 'Cluster'\n  // and optionTo is 'Oakley'.\n  const optionTo = mountainCaseWords(event.target.value);\n  const optionFor = optionForEvent(event.target);\n\n  options.each(function(_i, option) {\n    // the variable 'option' is just a data structure. it has no attr, data, show\n    // or hide methods so we have to query for it again\n    let optionElement = $(`#${elementId} option[value='${option.value}']`);\n    let data = optionElement.data();\n    let hide = data[`optionFor${optionFor}${optionTo}`] === false;\n\n    if(hide) {\n      optionElement.hide();\n\n      if(optionElement.prop('selected')) {\n        optionElement.prop('selected', false);\n\n        // when de-selecting something, the default is to fallback to the very first\n        // option. But there's an edge case where you want to hide the very first option,\n        // and deselecting it does nothing.\n        if(optionElement.next()){\n          optionElement.next().prop('selected', true);\n        }\n      }\n    } else {\n      optionElement.show();\n    }\n  });\n};\n\nfunction optionForEvent(target) {\n  let simpleName = shortId(target['id']);\n  return mountainCaseWords(simpleName);\n};\n\njQuery(function() {\n  makeChangeHandlers();\n});\n"],
  "mappings": "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",
  "names": []
}
